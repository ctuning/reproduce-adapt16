#include "base_hf1.h"

int AdjMatrix[NUM_NODES][NUM_NODES] = {
	{
		81, 92, 37, 74, 81, 
		6, 62, 92, 34, 39, 
		10, 51, 34, 59, 36, 
		44, 23, 65, 5, 27, 
		63, 17, 15, 6, 17, 
		63, 7, 47, 34, 41, 
		41, 31, 65, 37, 15, 
		10, 29, 37, 84, 6, 
		79, 94, 70, 72, 35, 
		76, 4, 21, 64, 77, 
		30, 5, 63, 53, 27, 
		64, 65, 7, 15, 77, 
	},
	{
		14, 57, 98, 88, 85, 
		30, 6, 11, 82, 55, 
		7, 54, 32, 78, 86, 
		77, 1, 57, 42, 66, 
		58, 19, 83, 83, 75, 
		7, 56, 25, 29, 100, 
		14, 61, 38, 24, 12, 
		59, 83, 41, 66, 65, 
		8, 4, 97, 19, 97, 
		27, 100, 54, 19, 64, 
		38, 23, 46, 80, 85, 
		11, 71, 92, 89, 98, 
	},
	{
		28, 9, 93, 90, 97, 
		53, 26, 66, 70, 47, 
		50, 92, 56, 71, 41, 
		78, 47, 38, 30, 44, 
		48, 43, 75, 72, 66, 
		72, 4, 66, 47, 28, 
		98, 18, 14, 24, 56, 
		52, 56, 16, 54, 94, 
		38, 8, 17, 82, 81, 
		48, 77, 51, 96, 53, 
		18, 55, 82, 87, 65, 
		7, 79, 16, 95, 43, 
	},
	{
		76, 22, 73, 40, 78, 
		81, 87, 59, 62, 13, 
		57, 61, 28, 3, 4, 
		63, 65, 47, 40, 77, 
		6, 30, 12, 68, 52, 
		55, 11, 70, 75, 76, 
		90, 51, 54, 9, 73, 
		91, 51, 95, 99, 12, 
		40, 3, 68, 91, 72, 
		22, 61, 68, 40, 79, 
		100, 67, 37, 34, 13, 
		88, 93, 32, 68, 34, 
	},
	{
		91, 22, 35, 33, 88, 
		63, 36, 80, 27, 53, 
		3, 72, 36, 60, 91, 
		4, 97, 12, 28, 3, 
		4, 6, 33, 75, 38, 
		79, 19, 52, 6, 77, 
		12, 17, 97, 24, 24, 
		31, 73, 20, 91, 32, 
		58, 69, 53, 72, 9, 
		96, 71, 5, 95, 34, 
		69, 79, 8, 83, 70, 
		92, 45, 46, 64, 53, 
	},
	{
		37, 73, 65, 40, 88, 
		82, 98, 27, 67, 61, 
		83, 63, 28, 61, 18, 
		57, 74, 44, 75, 59, 
		65, 90, 75, 62, 56, 
		78, 87, 19, 65, 88, 
		5, 50, 56, 11, 69, 
		65, 76, 60, 9, 29, 
		24, 88, 62, 18, 85, 
		99, 34, 60, 80, 33, 
		56, 53, 86, 89, 55, 
		79, 6, 82, 83, 82, 
	},
	{
		88, 32, 11, 39, 30, 
		99, 35, 11, 97, 79, 
		91, 7, 91, 42, 53, 
		22, 82, 83, 50, 45, 
		14, 31, 3, 31, 54, 
		59, 61, 3, 67, 8, 
		90, 88, 89, 51, 64, 
		94, 66, 49, 91, 69, 
		4, 100, 61, 92, 80, 
		68, 57, 50, 4, 2, 
		75, 32, 35, 71, 3, 
		7, 7, 39, 83, 3, 
	},
	{
		40, 60, 71, 40, 35, 
		90, 3, 43, 75, 52, 
		13, 12, 19, 54, 29, 
		36, 64, 14, 58, 46, 
		90, 43, 32, 61, 36, 
		27, 82, 12, 2, 54, 
		100, 47, 5, 53, 32, 
		46, 47, 39, 73, 14, 
		89, 75, 84, 48, 97, 
		8, 83, 31, 1, 66, 
		9, 28, 36, 2, 12, 
		30, 14, 49, 85, 1, 
	},
	{
		46, 15, 1, 42, 53, 
		59, 69, 63, 91, 49, 
		98, 77, 14, 8, 39, 
		79, 75, 15, 22, 14, 
		88, 16, 68, 6, 51, 
		29, 1, 2, 46, 63, 
		1, 74, 67, 28, 77, 
		24, 32, 73, 49, 16, 
		43, 7, 31, 91, 92, 
		92, 82, 14, 72, 27, 
		67, 71, 67, 28, 46, 
		46, 15, 11, 25, 76, 
	},
	{
		45, 30, 91, 67, 76, 
		21, 80, 42, 77, 61, 
		40, 43, 11, 35, 25, 
		18, 5, 17, 100, 97, 
		92, 30, 33, 12, 17, 
		55, 88, 78, 37, 93, 
		91, 3, 74, 14, 31, 
		77, 79, 70, 16, 16, 
		68, 40, 43, 19, 19, 
		31, 79, 10, 6, 12, 
		9, 51, 95, 99, 5, 
		41, 91, 88, 70, 43, 
	}
};

static inline int qcount (void)
{
	return(g_qCount);
}



static inline QITEM* dequeue (int *piNode, int *piDist, int *piPrev)
{
	QITEM *qKill = qHead;

	if (qHead != 0)
	{
		*piNode = qHead->iNode;
		*piDist = qHead->iDist;
		*piPrev = qHead->iPrev;
		qHead = qHead->qNext;
		g_qCount--;
		return qKill;
	}
	return 0;
}
static inline void enqueue (int iNode, int iDist, int iPrev)
{
	QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));
	QITEM *qLast = qHead;

	qNew->iNode = iNode;
	qNew->iDist = iDist;
	qNew->iPrev = iPrev;
	qNew->qNext = NULL;

	if (!qLast)
	{
		qHead = qNew;
	}
	else
	{
		while (qLast->qNext) qLast = qLast->qNext;
		qLast->qNext = qNew;
	}
	g_qCount++;
}
int hot_function1(int chStart, int chEnd)
{
	for (ch = 0; ch < NUM_NODES; ch++)
	{
		rgnNodes[ch].iDist = NONE;
		rgnNodes[ch].iPrev = NONE;
	}

	if (chStart == chEnd)
	{
		return 0;
	}
	else
	{
		rgnNodes[chStart].iDist = 0;
		rgnNodes[chStart].iPrev = NONE;

		enqueue (chStart, 0, NONE);

		while (qcount() > 0)
		{
			QITEM *tmp = dequeue (&iNode, &iDist, &iPrev);
			if(tmp != 0)
				free(tmp);
			for (i = 0; i < NUM_NODES; i++)
			{
				iCost = AdjMatrix[iNode][i];
				if (iCost != NONE)
				{
					if ((NONE == rgnNodes[i].iDist) ||
							(rgnNodes[i].iDist > (iCost + iDist)))
					{
						rgnNodes[i].iDist = iDist + iCost;
						rgnNodes[i].iPrev = iNode;
						enqueue (i, iDist + iCost, iNode);
					}
				}
			}
		}
	}

	return rgnNodes[chEnd].iDist;
}
